{"0": {
    "doc": "Attributes",
    "title": "Attributes",
    "content": "This page lists the most commonly used attributes currently supported by Spyglass. canonical . Special attribute that marks a union member as the canonical member. If a union has a canonical member, trying to read that union will always expect the canonical member. Syntax type RGB = ( #[canonical] int | [float] @ 3 | ) . color . Represents a color. This attribute has one required string option which is the format. Syntax #[color=\"dec_rgb\"] [float] @ 3 #[color=\"composite_rgb\"] int #[color=\"hex_rgb\"] string . command . Specifies that the string contains a command. This attribute has several options. Syntax #[command(slash=\"allowed\")] string #[command(slash=\"allowed\",empty=\"allowed\",max_length=32500)] string #[command(macro=\"implicit\")] string . deprecated . Marks the field as deprecated. Editors may strikethrough the field when used. It takes as argument a string specifying the version that it was deprecated in. Syntax #[deprecated=\"1.16\"] value?: Text, . dispatcher_key . Specifies that a string should match a key of a given dispatcher. Syntax #[dispatcher_key=\"mcdoc:custom_data\"] string . divisible_by . Specifies that a numeric value must be divisible by a given number . Syntax #[divisible_by=16] int . entity . Represents a selector, player name or uuid. Not to be confused with score_holder This attribute has two options: . | amount: either multiple or single . | type: either entities or players . | . Syntax #[entity(amount=\"single\",type=\"entities\")] string . game_rule . Specifies that a string should contain the name of a game rule. This attribute has one option: . | type: either boolean or int . | . Syntax #[game_rule(type=\"int\")] string . id . Specifies that a string should contain a resource location. It has a required option registry which can either be written as a shortform, or with more options: . | registry: any registry or pack category like item, block, loot_table, etc. | tags: one of allowed, implicit, or required . | . Syntax #[id=\"item\"] string #[id(registry=\"item\",tags=\"allowed\")] string . match_regex . Specifies that a string needs to match a given regex pattern. Not to be confused with regex_pattern . Syntax #[match_regex=\"^[a-z_]+$\"] string . nbt . A string containing SNBT. It has one option which is the type that the stringified SNBT needs to match. Syntax #[nbt=ItemStack] string . nbt_path . A string containing an NBT path. Syntax #[nbt_path] string . objective . A string containing a scoreboard objective name. Syntax #[objective] string . regex_pattern . A string containing a regex pattern. Not to be confused with match_regex. Syntax #[regex_pattern] string . score_holder . Allows the * wildcard, entity selectors and player names. Not to be confused with entity. Syntax #[score_holder] string . since . Makes the field or union member only available starting at a given version. Only release versions (no snapshots) are allowed. See also until. Syntax struct Example1 { #[since=\"1.19\"] entity: string, } type Example2 = ( string | #[since=\"1.20.5\"] int | ) . ❌ Invalid struct Example { entity: #[since=\"1.19\"] string, } . tag . A string containing a command tag name (obtained with /tag or in the Tags entity field). Syntax #[tag] string . team . A string containing a team name. Syntax #[team] string . text_component . A string containing stringified JSON representing a text component. Note that in versions since 1.21.5, you should use the ::java::util::text::Text type instead of stringified JSON. Syntax #[text_component] string . until . Makes the field or union member unavailable starting at a given version. Only release versions (no snapshots) are allowed. Note that the given version is not included in the range of versions where this field or member is accepted. See also since. Syntax struct Example1 { #[until=\"1.19\"] entity: string, } type Example2 = ( string | #[until=\"1.20.5\"] int | ) . ❌ Invalid struct Example { entity: #[until=\"1.19\"] string, } . ",
    "url": "/user/mcdoc/attributes.html#attributes",
    "relUrl": "/user/mcdoc/attributes.html#attributes"
  },"1": {
    "doc": "Attributes",
    "title": "Attributes",
    "content": "Table of Contents . | Attributes . | canonical | color | command | deprecated | dispatcher_key | divisible_by | entity | game_rule | id | match_regex | nbt | nbt_path | objective | regex_pattern | score_holder | since | tag | team | text_component | until | . | . ",
    "url": "/user/mcdoc/attributes.html",
    "relUrl": "/user/mcdoc/attributes.html"
  },"2": {
    "doc": "Custom Server Capabilities",
    "title": "experimental.spyglassmc.dataHackPubify",
    "content": "Request sent from client: spyglassmc/dataHackPubify . Parameters . | initialism: (string) . | . Response string . ",
    "url": "/developer/language-server/capabilities.html#experimental-spyglassmc-datahackpubify",
    "relUrl": "/developer/language-server/capabilities.html#experimental-spyglassmc-datahackpubify"
  },"3": {
    "doc": "Custom Server Capabilities",
    "title": "experimental.spyglassmc.inlayHints",
    "content": "Request sent from client: spyglassmc/inlayHints . Parameters . | textDocument . | uri . | . | range . | . Response InlayHint[] . ",
    "url": "/developer/language-server/capabilities.html#experimental-spyglassmc-inlayhints",
    "relUrl": "/developer/language-server/capabilities.html#experimental-spyglassmc-inlayhints"
  },"4": {
    "doc": "Custom Server Capabilities",
    "title": "experimental.spyglassmc.resetProjectCache",
    "content": "Request sent from client: spyglassmc/resetProjectCache . Parameters None. Response void . ",
    "url": "/developer/language-server/capabilities.html#experimental-spyglassmc-resetprojectcache",
    "relUrl": "/developer/language-server/capabilities.html#experimental-spyglassmc-resetprojectcache"
  },"5": {
    "doc": "Custom Server Capabilities",
    "title": "experimental.spyglassmc.showCacheRoot",
    "content": "Request sent from client: spyglassmc/showCacheRoot . Parameters None. Response void . ",
    "url": "/developer/language-server/capabilities.html#experimental-spyglassmc-showcacheroot",
    "relUrl": "/developer/language-server/capabilities.html#experimental-spyglassmc-showcacheroot"
  },"6": {
    "doc": "Custom Server Capabilities",
    "title": "Custom Server Capabilities",
    "content": " ",
    "url": "/developer/language-server/capabilities.html",
    "relUrl": "/developer/language-server/capabilities.html"
  },"7": {
    "doc": "Commands",
    "title": "Commands",
    "content": "spyglassmc.dataHackPubify . Data Hack Pubify a string. spyglassmc.resetProjectCache . Reset the symbols cache for the current project. spyglassmc.showCacheRoot . Show the cache folder of Spyglass in the platform-specific explorer program. spyglassmc.showOutput . Show the output panel with the logs of the Spyglass Language Server. ",
    "url": "/user/commands.html#commands",
    "relUrl": "/user/commands.html#commands"
  },"8": {
    "doc": "Commands",
    "title": "Commands",
    "content": " ",
    "url": "/user/commands.html",
    "relUrl": "/user/commands.html"
  },"9": {
    "doc": "Config",
    "title": "Example File",
    "content": "{ \"env\": { \"dataSource\": \"GitHub\", \"dependencies\": [ \"@vanilla-mcdoc\" ], \"feature\": { \"codeActions\": true, \"colors\": true, \"completions\": true, \"documentHighlighting\": true, \"documentLinks\": true, \"foldingRanges\": true, \"formatting\": true, \"hover\": true, \"inlayHint\": { \"enabledNodes\": [ \"mcfunction:command_child/unknown\" ] }, \"semanticColoring\": true, \"selectionRanges\": true, \"signatures\": true }, \"gameVersion\": \"Auto\", \"language\": \"Default\", \"permissionLevel\": 2, \"plugins\": [], \"mcmetaSummaryOverrides\": {}, \"useFilePolling\": false }, \"format\": { \"blockStateBracketSpacing\": { \"inside\": 0 }, \"blockStateCommaSpacing\": { \"before\": 0, \"after\": 1 }, \"blockStateEqualSpacing\": { \"before\": 0, \"after\": 0 }, \"blockStateTrailingComma\": false, \"eol\": \"auto\", \"nbtArrayBracketSpacing\": { \"inside\": 0 }, \"nbtArrayCommaSpacing\": { \"before\": 0, \"after\": 1 }, \"nbtArraySemicolonSpacing\": { \"after\": 1 }, \"nbtArrayTrailingComma\": false, \"nbtByteSuffix\": \"b\", \"nbtCompoundBracketSpacing\": { \"inside\": 0 }, \"nbtCompoundColonSpacing\": { \"before\": 0, \"after\": 1 }, \"nbtCompoundCommaSpacing\": { \"before\": 0, \"after\": 1 }, \"nbtCompoundTrailingComma\": false, \"nbtDoubleOmitSuffix\": false, \"nbtDoubleSuffix\": \"d\", \"nbtFloatSuffix\": \"f\", \"nbtListBracketSpacing\": { \"inside\": 0 }, \"nbtListCommaSpacing\": { \"before\": 0, \"after\": 1 }, \"nbtListTrailingComma\": false, \"nbtLongSuffix\": \"L\", \"nbtShortSuffix\": \"s\", \"selectorBracketSpacing\": { \"inside\": 0 }, \"selectorCommaSpacing\": { \"before\": 0, \"after\": 1 }, \"selectorEqualSpacing\": { \"before\": 0, \"after\": 0 }, \"selectorTrailingComma\": false, \"timeOmitTickUnit\": false }, \"lint\": { \"blockStateSortKeys\": null, \"nbtCompoundSortKeys\": null, \"selectorSortKeys\": null, \"commandStringQuote\": null, \"nbtKeyQuote\": null, \"nbtPathQuote\": null, \"nbtStringQuote\": null, \"selectorKeyQuote\": null, \"idOmitDefaultNamespace\": null, \"nameOfNbtKey\": null, \"nameOfObjective\": null, \"nameOfScoreHolder\": null, \"nameOfTag\": null, \"nameOfTeam\": null, \"nbtArrayLengthCheck\": true, \"nbtBoolean\": null, \"nbtListLengthCheck\": null, \"nbtTypeCheck\": \"loosely\", \"undeclaredSymbol\": [ { \"then\": { \"declare\": \"block\" } } ] }, \"snippet\": { \"executeIfScoreSet\": \"execute if score ${1:score_holder} ${2:objective} = ${1:score_holder} ${2:objective} $0\", \"summonAec\": \"summon minecraft:area_effect_cloud ~ ~ ~ {Age: -2147483648, Duration: -1, WaitTime: -2147483648, Tags: [\\\"${1:tag}\\\"]}\" } } . ",
    "url": "/user/config.html#example-file",
    "relUrl": "/user/config.html#example-file"
  },"10": {
    "doc": "Config",
    "title": "Environment Settings",
    "content": "TODO: Find a way to generate the docs and the Config interfaces from one single source of truth. ",
    "url": "/user/config.html#environment-settings",
    "relUrl": "/user/config.html#environment-settings"
  },"11": {
    "doc": "Config",
    "title": "Linting Rules",
    "content": ". | nameOfNbtKey . | nameOfObjective . | nameOfScoreHolder . | nameOfTag . | nameOfTeam . | undeclaredSymbol . | . ",
    "url": "/user/config.html#linting-rules",
    "relUrl": "/user/config.html#linting-rules"
  },"12": {
    "doc": "Config",
    "title": "Config",
    "content": "The config file can be put under the root of your workspace with either of the following names. | spyglass.json . | .spyglassrc.json . | . There&#8217;s no support for multiple config files or inheriting/overriding config files yet. ",
    "url": "/user/config.html",
    "relUrl": "/user/config.html"
  },"13": {
    "doc": "Developer Guides",
    "title": "Developer Guides",
    "content": " ",
    "url": "/developer/",
    "relUrl": "/developer/"
  },"14": {
    "doc": "Mcdoc",
    "title": "Writing Your Own",
    "content": "Any file with the .mcdoc extension will be picked up by Spyglass. If you start having multiple mcdoc files, it can be helpful to organize them in a mcdoc/ folder in your pack root, but this is not required. Defining an mcdoc type is pretty straightforward: . use ::java::util::text::Text use ::java::world::item::ItemStack struct MyQuest { type: string, prompt: Text, /// The item given to the player when completing the quest. reward_item?: ItemStack, } . The above example describes a type MyQuest, which is an object or compound (in mcdoc this is called a struct). The struct has 3 fields. Two required fields type and prompt. One optional field reward_item (indicated by the ?: field separator). Fields can have doc comments. These are comments above the field starting with /// and will be shown as a description of fields during autocomplete and hover interactions. At the top of the file you can see use statements. These can import types from other files. The example imports types from vanilla-mcdoc using the absolute path of the struct. If the above file was placed in quests.mcdoc, the absolute path of the struct type would be ::quests::MyQuest. ",
    "url": "/user/mcdoc/#writing-your-own",
    "relUrl": "/user/mcdoc/#writing-your-own"
  },"15": {
    "doc": "Mcdoc",
    "title": "Dispatching Types",
    "content": "A type on its own isn&#8217;t very useful. We need to tell Spyglass where this type is used in the data pack. This is where dispatchers are used. dispatch minecraft:storage[example:quests] to struct QuestsStorage { available?: [MyQuest], } . This dispatch statement tells Spyglass that the storage example:quests should have the type QuestsStorage, which in turn can reference other types in the file. Writing the following line in function file, you will notice that Spyglass suggests fields and gives errors for missing required fields: . data merge storage example:quests {available:[{ }]} . ",
    "url": "/user/mcdoc/#dispatching-types",
    "relUrl": "/user/mcdoc/#dispatching-types"
  },"16": {
    "doc": "Mcdoc",
    "title": "Mcdoc",
    "content": "Table of Contents . | Writing Your Own | Dispatching Types | . Mcdoc is a schema format for describing data structures used by Minecraft, including its CODECs, JSONs, and NBTs. It is a custom language that is interpreted by the Spyglass language server. The entirety of vanilla Minecraft is documented at the vanilla-mcdoc repository. This is a great place to look to learn about the syntax beyond this documentation! . ",
    "url": "/user/mcdoc/",
    "relUrl": "/user/mcdoc/"
  },"17": {
    "doc": "Home",
    "title": "User Testimonials",
    "content": "By far, by a huge margin, the best extension I&#8217;ve found for it. &#8212; slicedlime during his Twitch stream ",
    "url": "/#user-testimonials",
    "relUrl": "/#user-testimonials"
  },"18": {
    "doc": "Home",
    "title": "Getting Started",
    "content": "You can enjoy features provided by Spyglass on various text editors. VS Code . Install from the Marketplace. VSCodium . Install from the Open VSX Registry. Sublime Text . Planned. Zed Editor . Planned. ",
    "url": "/#getting-started",
    "relUrl": "/#getting-started"
  },"19": {
    "doc": "Home",
    "title": "Contributing",
    "content": ". | Create an issue . | GitHub Repository . | Localization . | . ",
    "url": "/#contributing",
    "relUrl": "/#contributing"
  },"20": {
    "doc": "Home",
    "title": "Home",
    "content": "Welcome to the documentation site for Spyglass, a project that aims at improving your editing experience with Minecraft: Java Edition data packs by providing handy features like auto-completion, real-time diagnostics, semantic coloring and such. It is planned to support multiple text editors, but for now, the only officially supported release is our vscode extension. ",
    "url": "/",
    "relUrl": "/"
  },"21": {
    "doc": "Maintainer Guides",
    "title": "Maintainer Guides",
    "content": " ",
    "url": "/maintainer/",
    "relUrl": "/maintainer/"
  },"22": {
    "doc": "Initialization Options",
    "title": "Initialization Options",
    "content": "The extension may provide optional initialization options to the language server on the initialize request. | (object) The initializationOptions . | inDevelopmentMode: (boolean) If the language server is launched under development mode. If set to true, a few seconds of delay will be introduced on the serverside when initializing to give NodeJS debugger time to attach to the server process. | . | . ",
    "url": "/developer/language-server/initialization-options.html",
    "relUrl": "/developer/language-server/initialization-options.html"
  },"23": {
    "doc": "Meta Registry",
    "title": "Symbol Registrar",
    "content": "A function that will be called after the symbol table is loaded from cache. ",
    "url": "/developer/meta-registry.html#symbol-registrar",
    "relUrl": "/developer/meta-registry.html#symbol-registrar"
  },"24": {
    "doc": "Meta Registry",
    "title": "Meta Registry",
    "content": " ",
    "url": "/developer/meta-registry.html",
    "relUrl": "/developer/meta-registry.html"
  },"25": {
    "doc": "nameOfNbtKey",
    "title": "Description",
    "content": "This rule enforces a consistent naming convention for keys in NBT compound tags and NBT paths. This linter only checks the naming in the following cases: . | This is a key definition in an nbtdoc compound definition block that is outside of the ::minecraft module; . | This is a key used in an NBT compound tag that doesn&#8217;t have an associated nbtdoc definition; OR . | This is a key used in an NBT path that doesn&#8217;t have an associated nbtdoc definition. | . ",
    "url": "/user/lint/nameOfNbtKey.html#description",
    "relUrl": "/user/lint/nameOfNbtKey.html#description"
  },"26": {
    "doc": "nameOfNbtKey",
    "title": "JSON Format",
    "content": ". | (string) A regex specifying the pattern of the name. The name will be considered valid if any part of it matches the regex, so use ^ and $ if you want the full name to be tested. | . Example 1. Snake case Config { \"lint\": { \"nameOfNbtKey\": \"^[a-z]+(_[a-z]+)*$\" } } . 👍 Good give @s stone{foo: true} give @s stone{foo_bar: true} . 👎 Bad give @s stone{FooBar: true} . Severity . All diagnostics provided by this linter will be of warning severity by default. You can wrap the config value in a tuple like this to change the severity to one of error, warning, information, or hint: . Config { \"lint\": { \"nameOfNbtKey\": [\"error\", &lt;value&gt;] } } . To Disable . If you do not wish to utilize this rule, simply set it to null: . Config { \"lint\": { \"nameOfNbtKey\": null } } . ",
    "url": "/user/lint/nameOfNbtKey.html#json-format",
    "relUrl": "/user/lint/nameOfNbtKey.html#json-format"
  },"27": {
    "doc": "nameOfNbtKey",
    "title": "nameOfNbtKey",
    "content": " ",
    "url": "/user/lint/nameOfNbtKey.html",
    "relUrl": "/user/lint/nameOfNbtKey.html"
  },"28": {
    "doc": "nameOfObjective",
    "title": "Description",
    "content": "This rule enforces a consistent naming convention for scoreboard objectives. ",
    "url": "/user/lint/nameOfObjective.html#description",
    "relUrl": "/user/lint/nameOfObjective.html#description"
  },"29": {
    "doc": "nameOfObjective",
    "title": "JSON Format",
    "content": ". | (string) A regex specifying the pattern of the name. The name will be considered valid if any part of it matches the regex, so use ^ and $ if you want the full name to be tested. | . Example 1. Snake case Config { \"lint\": { \"nameOfObjective\": \"^[a-z]+(_[a-z]+)*$\" } } . 👍 Good scoreboard objectives add foo scoreboard objectives add foo_bar . 👎 Bad scoreboard objectives add FooBar . Severity . All diagnostics provided by this linter will be of warning severity by default. You can wrap the config value in a tuple like this to change the severity to one of error, warning, information, or hint: . Config { \"lint\": { \"nameOfObjective\": [\"error\", &lt;value&gt;] } } . To Disable . If you do not wish to utilize this rule, simply set it to null: . Config { \"lint\": { \"nameOfObjective\": null } } . ",
    "url": "/user/lint/nameOfObjective.html#json-format",
    "relUrl": "/user/lint/nameOfObjective.html#json-format"
  },"30": {
    "doc": "nameOfObjective",
    "title": "nameOfObjective",
    "content": " ",
    "url": "/user/lint/nameOfObjective.html",
    "relUrl": "/user/lint/nameOfObjective.html"
  },"31": {
    "doc": "nameOfScoreHolder",
    "title": "Description",
    "content": "This rule enforces a consistent naming convention for score holder names (fake names). ",
    "url": "/user/lint/nameOfScoreHolder.html#description",
    "relUrl": "/user/lint/nameOfScoreHolder.html#description"
  },"32": {
    "doc": "nameOfScoreHolder",
    "title": "JSON Format",
    "content": ". | (string) A regex specifying the pattern of the name. The name will be considered valid if any part of it matches the regex, so use ^ and $ if you want the full name to be tested. | . Example 1. Snake case Config { \"lint\": { \"nameOfScoreHolder\": \"^[a-z]+(_[a-z]+)*$\" } } . 👍 Good execute if score foo objective matches 1 run say hello world! execute if score foo_bar objective matches 1 run say hello world! . 👎 Bad execute if score FooBar objective matches 1 run say hello world! . Severity . All diagnostics provided by this linter will be of warning severity by default. You can wrap the config value in a tuple like this to change the severity to one of error, warning, information, or hint: . Config { \"lint\": { \"nameOfScoreHolder\": [\"error\", &lt;value&gt;] } } . To Disable . If you do not wish to utilize this rule, simply set it to null: . Config { \"lint\": { \"nameOfScoreHolder\": null } } . ",
    "url": "/user/lint/nameOfScoreHolder.html#json-format",
    "relUrl": "/user/lint/nameOfScoreHolder.html#json-format"
  },"33": {
    "doc": "nameOfScoreHolder",
    "title": "nameOfScoreHolder",
    "content": " ",
    "url": "/user/lint/nameOfScoreHolder.html",
    "relUrl": "/user/lint/nameOfScoreHolder.html"
  },"34": {
    "doc": "nameOfTag",
    "title": "Description",
    "content": "This rule enforces a consistent naming convention for tags managed by the `/tag` command. ",
    "url": "/user/lint/nameOfTag.html#description",
    "relUrl": "/user/lint/nameOfTag.html#description"
  },"35": {
    "doc": "nameOfTag",
    "title": "JSON Format",
    "content": ". | (string) A regex specifying the pattern of the name. The name will be considered valid if any part of it matches the regex, so use ^ and $ if you want the full name to be tested. | . Example 1. Snake case Config { \"lint\": { \"nameOfTag\": \"^[a-z]+(_[a-z]+)*$\" } } . 👍 Good tag add foo tag add foo_bar . 👎 Bad tag add FooBar . Severity . All diagnostics provided by this linter will be of warning severity by default. You can wrap the config value in a tuple like this to change the severity to one of error, warning, information, or hint: . Config { \"lint\": { \"nameOfTag\": [\"error\", &lt;value&gt;] } } . To Disable . If you do not wish to utilize this rule, simply set it to null: . Config { \"lint\": { \"nameOfTag\": null } } . ",
    "url": "/user/lint/nameOfTag.html#json-format",
    "relUrl": "/user/lint/nameOfTag.html#json-format"
  },"36": {
    "doc": "nameOfTag",
    "title": "nameOfTag",
    "content": " ",
    "url": "/user/lint/nameOfTag.html",
    "relUrl": "/user/lint/nameOfTag.html"
  },"37": {
    "doc": "nameOfTeam",
    "title": "Description",
    "content": "This rule enforces a consistent naming convention for teams. ",
    "url": "/user/lint/nameOfTeam.html#description",
    "relUrl": "/user/lint/nameOfTeam.html#description"
  },"38": {
    "doc": "nameOfTeam",
    "title": "JSON Format",
    "content": ". | (string) A regex specifying the pattern of the name. The name will be considered valid if any part of it matches the regex, so use ^ and $ if you want the full name to be tested. | . Example 1. Snake case Config { \"lint\": { \"nameOfTeam\": \"^[a-z]+(_[a-z]+)*$\" } } . 👍 Good team add foo team add foo_bar . 👎 Bad team add FooBar . Severity . All diagnostics provided by this linter will be of warning severity by default. You can wrap the config value in a tuple like this to change the severity to one of error, warning, information, or hint: . Config { \"lint\": { \"nameOfTeam\": [\"error\", &lt;value&gt;] } } . To Disable . If you do not wish to utilize this rule, simply set it to null: . Config { \"lint\": { \"nameOfTeam\": null } } . ",
    "url": "/user/lint/nameOfTeam.html#json-format",
    "relUrl": "/user/lint/nameOfTeam.html#json-format"
  },"39": {
    "doc": "nameOfTeam",
    "title": "nameOfTeam",
    "content": " ",
    "url": "/user/lint/nameOfTeam.html",
    "relUrl": "/user/lint/nameOfTeam.html"
  },"40": {
    "doc": "Profilers",
    "title": "Profilers",
    "content": "Profiler IDs . | cache#save . | cache#load . | project#ready . | . ",
    "url": "/maintainer/profilers.html",
    "relUrl": "/maintainer/profilers.html"
  },"41": {
    "doc": "Specification",
    "title": "Project root",
    "content": "Normally, the workspace (the directory where the mcdoc interpreter operates: for command line tools, this could be the working directory; for code editors like VS Code, this could be the root directory shown in the sidebar explorer) is considered as the root of a mcdoc project. If, however, there exists a folder named mcdoc directly under the workspace and all mcdoc files inside the workspace are stored under that direcotry, it will be considered as the root instead. ",
    "url": "/user/mcdoc/specification.html#project-root",
    "relUrl": "/user/mcdoc/specification.html#project-root"
  },"42": {
    "doc": "Specification",
    "title": "Syntax syntax",
    "content": "Here is the syntax used by this document to describe the syntax of mcdoc&#8201;&#8212;&#8201;syntax syntax, if you wish. Table 1. Syntax syntax | Symbol | Meaning | . | str . | Literal str . | . | U+xxxx . | Unicode character with the code point xxxx . | . | A* . | A repeated zero or more times . | . | A+ . | A repeated one or more times . | . | A? . | A repeated zero or one times . | . | A | B . | Either A or B . | . | [A B C] . | One of the literals A, B, or C . | . | [A-Z] . | Any literal from A to Z . | . | (A) . | General grouping . | . | notA . | Anything not A . | . | Aexcept: B . | A except B . | . | Alookahead: B . | A followed by B, but only consumes A . | . | Anochild: B . | A but B should not be a child of it . | . | NAME . | A referenced token rule . | . | Name . | A referenced parser rule . | . A token rule syntax cannot have any whitespaces (spaces, tabs, CRs, or LFs) or tokens in between the individual parts. A parser rule syntax can have whitespaces and COMMENTS in between. All syntax rules should be greedy (i.e. consume as many characters as possible). ",
    "url": "/user/mcdoc/specification.html#syntax-syntax",
    "relUrl": "/user/mcdoc/specification.html#syntax-syntax"
  },"43": {
    "doc": "Specification",
    "title": "Comments",
    "content": "SYNTAX (TOKEN) . COMMENTS COMMENT* . COMMENT // lookahead: not/ (notEOL)* (EOL | EOF) . EOL End of line: CR (Unicode U+000D) or LF (Unicode U+000A). EOF End of file. Comments can be used in mcdoc to write information that can be seen only by other users viewing/editing your mcdoc files. They are ignored by a mcdoc interpreter. To write a comment, simply put down two forward slashes (//)&#8201;&#8212;&#8201;everything following them, until the end of the line, is treated as part of the comment. They can be put anywhere where a whitespace is allowed. Comments, however, cannot start with triple slashes (///), as that&#8217;s reserved for Doc comments. Example 1. Comments // This is a comment. struct Foo { Bar: boolean, // This is another one. } . ",
    "url": "/user/mcdoc/specification.html#comments",
    "relUrl": "/user/mcdoc/specification.html#comments"
  },"44": {
    "doc": "Specification",
    "title": "Doc comments",
    "content": "SYNTAX . Prelim DocComments Attributes . DocComments DOC_COMMENT* Although this is a syntax rule, no regular comments are allowed between the individual DOC_COMMENT. Only whitespaces (including newlines) should be allowed. SYNTAX (TOKEN) . DOC_COMMENT /// (notEOL)* (EOL | EOF) . Doc comments are similar to comments syntax-wise&#8201;&#8212;&#8201;they start with triple slashes (///) instead. A block of doc comments can provide human-readable documentation for the component right after it to users of your mcdoc files. Unlike regular comments, doc comments can only be put in front of enum definitions, enum fields, struct definitions, struct fields, and type aliases, as part of [prelim]s. The text content of a doc comment block should be treated as a MarkDown content, with the leading triple slashes (and up to one leading space after the slashes if all lines within the block share that one leading space) stripped. Example 2. Doc comments /// This doc comment describes the struct Foo. /// External tools, like VS Code, may show this block of text when the user hovers over the name \"Foo\". struct Foo { /// This is another doc comment describing the field \"Bar\". Bar: boolean, // This is just a regular comment because it only starts with two slashes. } . | | As the content of a doc comment block is treated as MarkDown, certain characters might have special meaning. For example, if you write &lt;foo&gt; inside the doc comment, it might disappear when being shown to a user, as it may get interperted as an XML tag by a MarkDown parser. Escaping those special characters with a backslash (\\) (e.g. \\&lt;foo&gt;) will fix this. | . ",
    "url": "/user/mcdoc/specification.html#doc-comments",
    "relUrl": "/user/mcdoc/specification.html#doc-comments"
  },"45": {
    "doc": "Specification",
    "title": "Integer",
    "content": "SYNTAX (TOKEN) . INTEGER 0 | [- +]? [1-9] [0-9]* . An integer represents a whole number. Example 3. Integers 0 +123 -456 . ",
    "url": "/user/mcdoc/specification.html#integer",
    "relUrl": "/user/mcdoc/specification.html#integer"
  },"46": {
    "doc": "Specification",
    "title": "Float",
    "content": "SYNTAX (TOKEN) . FLOAT [- +]? [0-9]+ FLOAT_EXPONENT? | [- +]? [0-9]* . [0-9]+ FLOAT_EXPONENT? . FLOAT_EXPONENT [e E] [- +]? [0-9]+ . A float represents a decimal number. Scientific notation may be used with the letter e (case-insensitive). Example 4. Floats 1 +1.2 -1.2e3 // -1.2×103 . ",
    "url": "/user/mcdoc/specification.html#float",
    "relUrl": "/user/mcdoc/specification.html#float"
  },"47": {
    "doc": "Specification",
    "title": "Typed Number",
    "content": "SYNTAX (TOKEN) . TYPED_NUMBER INTEGER [b B s S l L]? | FLOAT [d D f F]? . A typed number is similar to a number used in SNBTs syntax-wise. It&#8217;s a normal number followed by a suffix indicating its type: . Table 2. Suffix table | Suffix (case-insensitive) | Type | . | b . | Byte . | . | s . | Short . | . | L . | Long . | . | f . | Float . | . | d . | Double . | . | (No suffix, integer) . | Integer . | . | (No suffix, decimal) . | Double . | . Example 5. Typed numbers 1b // Byte 1 1 // Integer 1 1.2 // Double 1.2 1.2d // Double 1.2 1.2e1f // Float 12 . ",
    "url": "/user/mcdoc/specification.html#typed-number",
    "relUrl": "/user/mcdoc/specification.html#typed-number"
  },"48": {
    "doc": "Specification",
    "title": "Number range",
    "content": "SYNTAX (TOKEN) . FLOAT_RANGE RANGE_DELIMITER? FLOAT | FLOAT RANGE_DELIMITER FLOAT? . RANGE_DELIMITER .. | ..&lt; | &lt;.. | &lt;..&lt; . INT_RANGE RANGE_DELIMITER? INTEGER | INTEGER RANGE_DELIMITER INTEGER? . A number range represents a range of number. Its syntax derives from number ranges used in Minecraft commands, with additional support for signaling an exclusive end using the strictly less than symbol (&lt;). There are two types of ranges in mcdoc: float ranges, which consist of Floats, and integer ranges, which consists of Integers. Example 6. Number ranges 1 // Exactly 1 1..1 // Exactly 1 1..2 // Between 1 and 2 (inclusive on ends) 1&lt;..&lt;2 // Between 1 and 2 (exclusive on ends) 4.2.. // Greater than or equal to 4.2 4.2&lt;.. // Greater than 4.2 ..9.1 // Smaller than or equal to 9.1 ..&lt;9.1 // Smaller than 9.1 . ",
    "url": "/user/mcdoc/specification.html#number-range",
    "relUrl": "/user/mcdoc/specification.html#number-range"
  },"49": {
    "doc": "Specification",
    "title": "String",
    "content": "SYNTAX (TOKEN) . STRING \" (not[\" \\ UNICODE_CC] | (\\ [b f n r t \\ \"]))* \" . UNICODE_CC Unicode control characters. A string represents a sequence of characters. It must be surrounded by double quotation marks (\"). Certain characters need to be escaped by a backslash (\\). Table 3. Escape characters | Escape sequence | Meaning | . | \\\" . | A double quotation mark (\", Unicode U+0022) . | . | \\\\ . | A backslash (\\, Unicode U+005C) . | . | \\b . | A backspace (Unicode U+0008) . | . | \\f . | A form feed (Unicode U+000C) . | . | \\n . | A newline (Unicode U+000A) . | . | \\r . | A carriage return (Unicode U+000D) . | . | \\t . | A tab (Unicode U+0009) . | . Example 7. Strings \"foo\" // A string representing foo \"bar\\\"qux\\\\baz\" // A string representing bar\"qux\\baz . ",
    "url": "/user/mcdoc/specification.html#string",
    "relUrl": "/user/mcdoc/specification.html#string"
  },"50": {
    "doc": "Specification",
    "title": "Resource location",
    "content": "SYNTAX (TOKEN) . RES_LOC RES_LOC_CHAR* : RES_LOC_CHAR* (/ RES_LOC_CHAR*)* . RES_LOC_CHAR [a-z 0-9 - _ .] . A resource location is similar to the resource location from Minecraft syntax-wise, except that a colon (:) must exist to disambiguate this from an Identifier. Example 8. Resource locations minecraft:foo :foo // This also means minecraft:foo, and is legal in Minecraft itself. spyglassmc:bar . ",
    "url": "/user/mcdoc/specification.html#resource-location",
    "relUrl": "/user/mcdoc/specification.html#resource-location"
  },"51": {
    "doc": "Specification",
    "title": "Identifier",
    "content": "SYNTAX (TOKEN) . IDENTIFIER ((IDENT_START) (IDENT_CONTINUE)*)except: RESERVED_WORDS . IDENT_START Any character in the Unicode general categories &#8220;Letter (L)&#8221; or &#8220;Letter Number (Nl)&#8221; . IDENT_CONTINUE IDENT_START | U+200C | U+200D | (any character in the Unicode general categories &#8220;Non-Spacing Mark (Mn)&#8221;, &#8220;Spacing Combining Mark (Mc)&#8221;, &#8220;Decimal Digit Number (Nd)&#8221;, or &#8220;Connector Punctuation (Pc)&#8221;) . RESERVED_WORDS any | boolean | byte | double | enum | false | float | int | long | short | string | struct | super | true . An identifier is a case-sensitive name given to a type definition in mcdoc. It can contain any Unicode letters, numbers, and the underscore (_), but must not start with a digit. It also must not be named after a list of reserved words. Example 9. Identifiers struct Foo { // Foo is an identifier. B_1: boolean, // B_1 is an identifier. } . ",
    "url": "/user/mcdoc/specification.html#identifier",
    "relUrl": "/user/mcdoc/specification.html#identifier"
  },"52": {
    "doc": "Specification",
    "title": "Path",
    "content": "SYNTAX (TOKEN) . PATH (::)? PATH_SEGMENT (:: PATH_SEGMENT)* . PATH_SEGMENT IDENTIFIER | super . A path is used to locate a type definition across the mcdoc project. A sequence of two colons (::) is used as the path separater. If a path starts with the path separater, it is an absolute path and will be resolved from the project root. Otherwise it is a relative path and will be resolved from the absolute path of the current file. The absolute path of a file is determined by connecting the names of all its parent folders up until the root and the file&#8217;s own name (excluding the .mcdoc file extension) with the path separater, prepended by the path separater, with a special case for files named mod.mcdoc&#8201;&#8212;&#8201;they will not be part of their paths. The absolute path of a type definition is the absolute path of the file where it resides joined with the identifier of the type definition by the path separater. If multiple files/type definitions ended up having the same path, only the earliest loaded one will take effect; all subsequent ones should be warned and ignored by the mcdoc interpreter. For relative paths, the keyword super may be used to move up one level from the current absolute path. Example 10. Paths / foo.mcdoc (1) foo/ bar.mcdoc (2) mod.mcdoc (3) qux.mcdoc (4) . | 1 | The absolute path of this file is ::foo. | . | 2 | The absolute path of this file is ::foo::bar. | . | 3 | The absolute path of this file is ::foo instead of ::foo::mod, as files named mod.mcdoc are special. This has the same path as &lt;1&gt;, and as &lt;1&gt; is shallower in the file structure, it is loaded first, meaning &lt;3&gt; is ignored in favor of &lt;1&gt; and a warning should be given. | . | 4 | The absolute path of this file is ::qux. | . If the content of /foo/bar.mcdoc is . struct Foo {} (1) type Bar = super::super::qux::Something (2) . | 1 | The absolute path for struct Foo is ::foo::bar::Foo | . | 2 | The absolute path for type alias Bar is ::foo::bar::Bar. The relative path is interpreted as follows: . | Absolute path of the residing file (/foo/bar.mcdoc) is ::foo::bar. The given relative path is super::super::qux::Something. | Encounters keyword super, moves one level up to ::foo. Remaining relative path is super::qux::Something. | Encounters keyword super, moves one level up to ::. Remaining relative path is qux::Something. | Encounters identifier qux, moves down to ::qux. Remaining relative path is Something. | Encounters identifier Something, moves down to ::qux::Something. Relative path has been resolved. | The type alias Bar therefore points to the type definition named Something in file /qux.mcdoc. | . | . ",
    "url": "/user/mcdoc/specification.html#path",
    "relUrl": "/user/mcdoc/specification.html#path"
  },"53": {
    "doc": "Specification",
    "title": "Type",
    "content": "SYNTAX . Type Attributes UnattributedType (IndexBody | TypeArgBlock)* . UnattributedType KeywordType | StringType | LiteralType | NumericType | PrimitiveArrayType | ListType | TupleType | Enum | Struct | ReferenceType | DispatcherType | UnionType . TypeArgBlock &lt; &gt; | &lt; Type (, Type)* ,? &gt; . A type is an essential component of the mcdoc format. It defines a schema that actual data values must fit in to be valid. | | Mcdoc may be used to describe the format of a wide range of data. This section will only provide some JSON data as examples for each type. | . any type . SYNTAX . KeywordType any | boolean . The any type serves as the top type of mcdoc&#8217;s type system. Any another types, including any itself, are assignable to any. any cannot be assigned to any other types other than any. Example 11. Valid values for the any type null true [0, 1, 2, 3] { \"foo\": \"bar\" } . boolean type . The boolean type indicates a boolean value (false or true) is expected. Example 12. Valid values for the boolean type false true . string type . SYNTAX . StringType string (@ INT_RANGE)? . The string type indicates a string value is expected. The optional range defines the range of the length of the string. Example 13. Valid values for the string type \"foo\" \"bar\" . Literal boolean type . SYNTAX . LiteralType false | true | STRING | TYPED_NUMBER . A literal boolean type is one of the two boolean values (false and true) that the data must match to be valid. Example 14. Literal boolean types false true . Literal string type . A literal string type is a string value the data must match literally to be valid. Example 15. Literal string types \"\" \"foo\" . Literal number type . A literal number type includes a numeric value and a type the data must match literally to be valid. Example 16. Literal number types -1 1.2f 42L . Numeric type . SYNTAX . NumericType byte (@ INT_RANGE)? | short (@ INT_RANGE)? | int (@ INT_RANGE)? | long (@ INT_RANGE)? | float (@ FLOAT_RANGE)? | double (@ FLOAT_RANGE)? . A numeric type indicates the data must be of that type to be valid. If the optional range is provided, then the data must also fit into that range. Example 17. Numeric types byte short@1.. float @ 4.2..9.1 . Primitive array type . SYNTAX . PrimitiveArrayType byte (@ INT_RANGE)? [] (@ INT_RANGE)? | int (@ INT_RANGE)? [] (@ INT_RANGE)? | long (@ INT_RANGE)? [] (@ INT_RANGE)? . A primitive array type indicates the data must be a collection of certain numeric values. The first optional range defines the range the value must be in, while the second optional range defines the range of the size of the collection. Example 18. Primitive array types byte[] // A collection of bytes. byte#0..1[] // A collection of bytes 0 or 1. int[] # 4 // A collection of 4 integers. long#0..[] # 3.. // A collection of 3 or more non-negative longs. List type . SYNTAX . ListType [ Type ] (@ INT_RANGE)? . A list type indicates the data must be a collection of a certain other type. The optional range defines the range of the size of the collection. Example 19. List types [byte] // A collection of bytes. [[string]] // A collection of collections of strings. [struct Foo {}] // A collection of structs. | | Unlike NBT, JSON doesn&#8217;t distinguish between primitive arrays and lists&#8201;&#8212;&#8201;it only has an array type. Therefore, byte[] and [byte] means essentially the same thing for JSON validation. | . Tuple type . SYNTAX . TupleType [ Type , ] [ Type (, Type)+ ,? ] . A tuple type indicates the data must be a collection of certain other types arranged in a specified order. To distinguish a tuple type containing only one element from a list type, a trailing comma (,) needs to be added after the type. Alternatively, you can also use a list type with size 1 to represent a tuple with one element (e.g. [byte] @ 1). Example 20. Tuple types [byte,] // A tuple of a byte. [string, boolean] // A tuple of a string followed by a boolean. | | Tuple types are generally not useful for NBT structures, as NBT doesn&#8217;t have collections of mixed types. | . Enum . SYNTAX . Enum Prelim enum ( ENUM_TYPE ) IDENTIFIER? EnumBlock . EnumBlock { } | { EnumField (, EnumField)* ,? } . EnumField Prelim IDENTIFIER = ENUM_VALUE . SYNTAX (TOKEN) . ENUM_TYPE byte | short | int | long | string | float | double . ENUM_VALUE TYPED_NUMBER | STRING Although TYPED_NUMBER is expected as the value for enums, the user can write the numbers without the proper suffixes as the mcdoc interpreter is able to infer the proper type from the enum definition. TODO . Struct . SYNTAX . Struct Prelim struct IDENTIFIER? StructBlock . StructBlock { } | { StructField (, StructField)* ,? } . StructField Prelim StructKey ?? : Type | Attributes ... Type For the spreading syntax (...), if the type after the spread operator cannot be resolved as a struct type, only the attributes on the type will be copied over to the current struct. StructKey STRING | IDENTIFIER | [ Type ] . A struct defines the schema of a dictionary-like structure consisting of key-value pairs, like a JSON object or an NBT compound tag. If a key is duplicated, the type of the later one will override that of the former one. A question mark (?) can be added between the key and the colon (:) to indicate an optional field. Example 21. Data pack tag struct struct Tag { replace?: boolean, values: [string], } . The spread operator (three dots, ...) followed by a struct type can be used to reuse fields from another struct. Example 22. Spread syntax struct Player { ...Mob, // Reuse fields from the Mob struct here. abilities: Abilities, CustomName: (), // Overrides CustomName from the Mob struct to an empty union. } . Although type parameters are not directly allowed in struct definitions, you can inline a struct on the right hand side of a type alias definition. Example 23. Type parameter type Tag&lt;V&gt; = struct { replace?: boolean, values: [V], } type BlockTag = Tag&lt;#[id=block] string&gt; type EntityTypeTag = Tag&lt;#[id=entity_type] string&gt; type FunctionTag = Tag&lt;#[id=function] string&gt; type ItemTag = Tag&lt;#[id=item] string&gt; . Reference type . SYNTAX . ReferenceType PATH . Dispatcher type . SYNTAX . DispatcherType RES_LOC IndexBody . TODO . The fallback case is used when the index is omitted. Union type . SYNTAX . UnionType ( ) | ( Type (| Type)* |? ) A pair of empty parentheses removes this field definition from the struct.kk . TODO . Indexing on a type . SYNTAX . IndexBody [ Index (, Index)* ,? ] Multiple indices can be put inside the brackets to access multiple types from the target. Example 24. Access multiple types from a dispatcher minecraft:entity[ender_dragon, wither] &#8594; Produces a union of the type for the ender dragon and the type for the wither. minecraft:entity[[id], allay] &#8594; Produces a union of the type for the entity at id dynamically and the allay. Index STATIC_INDEX_KEY | DynamicIndex . DynamicIndex [ ACCESSOR ] . SYNTAX (TOKEN) . STATIC_INDEX_KEY %fallback | %none | %unknown | IDENTIFIER | STRING | RES_LOC . ACCESSOR ACCESSOR_KEY (. ACCESSOR_KEY)* . ACCESSOR_KEY %key | %parent | IDENTIFIER | STRING . Indices can access a type from a dispatcher or get a field type from an existing struct, both statically (i.e. the user provides the key literally in the mcdoc file) and dynamically (i.e. the user specifies a way to get the key from the given data structure at runtime). Example 25. Static and dynamic indices struct Foo { id: string, cow_data: minecraft:entity[cow], (1) dynamic_entity_data: minecraft:entity[[id]], (2) command: minecraft:block[command_block][Command], (3) dynamic_memories: minecraft:entity[[id]][Brain][memories], (4) } . | 1 | Static index on a dispatcher. | . | 2 | Dynamic index on a dispatcher. | . | 3 | Static index on a dispatcher, followed by a static index on a struct. | . | 4 | Dynamic index on a dispatcher, followed by two static indices on two structs. | . The default value used for all cases (including the two mutable special keys, %none and %unknown) is the fallback case. Example 26. Special static key: %fallback The %fallback key can be used to access the fallback case of a dispatcher. It cannot be used on the left hand side of dispatch statements, as the fallback case is generated automatically and cannot be manually declared. type AnyEntity = minecraft:entity[%fallback] . Example 27. Special static key: %none The case corresponding to %none is used when the accessor of a dynamic index gets no value at runtime. struct RandomIntGenerator { type?: (\"uniform\" | \"binomial\" | \"constant\"), (1) ...minecraft:random_int_generator[[type]], (2) } dispatch minecraft:random_int_generator[uniform, %none] to struct { min?: int, max?: int } (3) . | 1 | Note that type is defined as optional here. | . | 2 | The value of type at runtime is used as a dynamic index here. | . | 3 | The case corresponding to %none is dispatched to the struct here, so the random int generator can still get validated as a uniform generator properly when no value for type is provided at runtime. | . Example 28. Special static key: %unknown The case corresponding to %unknown is used when an unknown key is used to access the dispatcher. dispatch minecraft:block[%unknown] to () . Example 29. Special accessor key: %key The %key accessor key can be used to access the key where the current runtime value is. struct DebugStick { DebugProperty: struct { [#[id=block] string]: mcdoc:block_state_name[[%key]], // Get the type of the block state names of the block stored in the key. }, } . This struct can be used to validate the following data: . { \"DebugProperty\": { \"minecraft:anvil\": \"facing\", \"minecraft:oak_fence\": \"east\" } } . Example 30. Special accessor key: %parent The %parent accessor key can be used to access the parent value of the current runtime value. struct Item { id: #[id=item] string, tag: struct ItemTag { BlockStateTag: mcdoc:block_item_states[[%parent.id]] }, } . TODO . ",
    "url": "/user/mcdoc/specification.html#type",
    "relUrl": "/user/mcdoc/specification.html#type"
  },"54": {
    "doc": "Specification",
    "title": "File Structure",
    "content": "SYNTAX . File (Struct | Enum | TypeAlias | UseStatement | Injection | DispatchStatement)* . An mcdoc is made of structs, enums, type alias statements, use statements, injections, and dispatch statements. ",
    "url": "/user/mcdoc/specification.html#file-structure",
    "relUrl": "/user/mcdoc/specification.html#file-structure"
  },"55": {
    "doc": "Specification",
    "title": "Type alias statement",
    "content": "SYNTAX . TypeAlias Prelim type IDENTIFIER TypeParamBlock? = Type . TypeParamBlock &lt; &gt; | &lt; TypeParam (, TypeParam)* ,? &gt; . TypeParam IDENTIFIER . A type alias can be created to refer to another complicated type for better code readability and reusability. Example 31. Type aliases type Integer = (byte | short | int | long) type Float = (float | double) type Number = (Integer | Float) . Sometimes we may want to create different type definitions that have roughly the same structure and only differ in some small aspects. Instead of duplicating codes, we can create a \"template\" type alias with type parameters. The right-hand side of the type alias statement can then reference those type parameters, which will get replaced by actual types when the type alias is instantiated elsewhere. Example 32. Type aliases with type parameters type NumericRange&lt;T&gt; = ( (1) T | (2) [T, T] | (2) struct { min: T, max: T } (2) ) type FloatRange = NumericRange&lt;float&gt; (3) type IntegerRange = NumericRange&lt;int&gt; (3) type NaturalRange = NumericRange&lt;int @ 0..&gt; (3) . | 1 | The type parameter T is declared in the angle brackets. | . | 2 | The type parameter T can now be referenced on the right-hand side. | . | 3 | When the NumericRange type alias is referenced elsewhere, an actual type must be suplied for the type parameter. | . Binding type parameters . All path references are resolved by the rules described in Path, and type parameter references are no exceptions. When a type parameter is declared in a type alias statement, it is temporarily bound to the current module until the end of the statement. Therefore, just like other type definitions, type parameters should be unique at the module scope. Example 33. Duplicated type parameter identifiers // File '/example.mcdoc' struct T {} type List&lt;T&gt; = [T] (1) // ^ // WARNING: Duplicated declaration for \"::example::T\" . | 1 | The declaration for T is warned and ignored, and the reference of T on the right-hand side actually refers to the struct T defined above. | . type List&lt;T&gt; = [T] type Struct&lt;T&gt; = struct { value: T } (1) . | 1 | This is fine, as although T is also declared in the List type alias statement, the effect of that declaration only lives until the end of that statement. | . ",
    "url": "/user/mcdoc/specification.html#type-alias-statement",
    "relUrl": "/user/mcdoc/specification.html#type-alias-statement"
  },"56": {
    "doc": "Specification",
    "title": "Use statement",
    "content": "SYNTAX . UseStatement use PATH (as IDENTIFIER)? . TODO . ",
    "url": "/user/mcdoc/specification.html#use-statement",
    "relUrl": "/user/mcdoc/specification.html#use-statement"
  },"57": {
    "doc": "Specification",
    "title": "Injection",
    "content": "SYNTAX . Injection inject (EnumInjection | StructInjection) . EnumInjection enum ( ENUM_TYPE ) PATH EnumBlock . StructInjection struct PATH StructBlock . TODO . ",
    "url": "/user/mcdoc/specification.html#injection",
    "relUrl": "/user/mcdoc/specification.html#injection"
  },"58": {
    "doc": "Specification",
    "title": "Dispatch statement",
    "content": "SYNTAX . DispatchStatement Prelim dispatch RES_LOC IndexBodynochild: DynamicIndex TypeParamBlock? to Type . A dispatcher can be used to dispatch to a specific type from a given index. Each case of a dispatcher can be declared by a DispatchStatement and accessed by a DispatcherType. Dispatchers are named after Resource locations, so unlike other values in mcdoc that are named after Identifiers which require being imported before they can be used in an external file, dispatchers are inherently global and can be accessed anywhere inside an mcdoc project. Fallback case When an unknown index is used to access a dispatcher, a union consisting of all types registered under the dispatcher is generated as a fallback case at runtime. The union is marked with the \"nonexhaustive\" metadata. TODO . ",
    "url": "/user/mcdoc/specification.html#dispatch-statement",
    "relUrl": "/user/mcdoc/specification.html#dispatch-statement"
  },"59": {
    "doc": "Specification",
    "title": "Attribute",
    "content": "SYNTAX . Attributes Attribute* . Attribute #[ IDENTIFIER ] | #[ IDENTIFIER = Value ] | #[ IDENTIFIER TreeValue ] . Value Type | TreeValue . TreeValue ( TreeBody? ) | [ TreeBody? ] | { TreeBody? } . TreeBody PositionalValues ,? | NamedValues ,? | PositionalValues , NamedValues ,? . PositionalValues Value (, Value)* . NamedValues NamedValue (, NamedValue)* . NamedValue (IDENTIFIER | STRING) = Value | (IDENTIFIER | STRING) TreeValue . Example 34. Attribute examples (non-final) All following examples are syntactically legal under the current attribute proposal. Which ones should be semantically legal, however, is still under debate. struct Foo { #[id=item] id1: string, id2: #[id=item] string, // id1 and id2 will likely both be supported and have equivalent effects. blockStateValue1: ( #[serializable] string | byte | short | int | long | float | double ), #[serialize_to=string] blockStateValue2: (string | byte | short | int | long | float | double), evilUUID1: ( #[until(\"1.16\", uuid_string_to_compound)] #[parser=uuid] string | #[until(\"1.17\", uuid_compound_to_array)] MostLeastCompound | int[] @ 4 ), #[history{ (#[parser=uuid] string, until=\"1.16\", updater=uuid_string_to_compound), (MostLeastCompound, until=\"1.17\", updater=uuid_compound_to_array), }] evilUUID2: int[] @ 4 } . ",
    "url": "/user/mcdoc/specification.html#attribute",
    "relUrl": "/user/mcdoc/specification.html#attribute"
  },"60": {
    "doc": "Specification",
    "title": "Type instantiation",
    "content": "Type instantiation is the process of converting a user-defined type into a type that is easy for data validators to consume. A user-defined type can be categorized as follows for instantiation purposes: . Indexed type An indexed type. Self-contained type A type where all information needed for data validators to function are contained inside the type itself. Includes any type, boolean type, string type, Literal boolean type, Literal string type, Literal number type, Numeric type, Primitive array type, and Enum. Container type A type that provides some information on its own, but needs information from its children for the validation to be complete. Includes List type, Tuple type, and Struct. Reference type A Reference type. Dispatcher type A Dispatcher type. Union type A Union type. Different procedures are used to instantiate each category of user-defined types. Instantiate indexed type . First instantiate the part without the indices, then resolve the index on the instantiated type. Repeat until all indices are resolved. Instantiate self-contained type . Self-contained types do not need to be instantiated. Instantiate container type . Container types do not need to be instantiated. Their children are instantiated when needed lazily. Instantiate reference type . Dereference the path. If there are type parameters, replace all occurrences of them in the template type with the provided actual types. The resulted type is then instantiated again following the instantiation rules. Instantiate dispatcher type . Dispatch the type. The resulted type is then instantiated again following the instantiation rules. Union type . Each member type of the union is individually instantiated. Aftermath of instantiation . After a type is instantiated following the above rules, it should be simplified before being returned. ",
    "url": "/user/mcdoc/specification.html#type-instantiation",
    "relUrl": "/user/mcdoc/specification.html#type-instantiation"
  },"61": {
    "doc": "Specification",
    "title": "Type simplification",
    "content": "TODO . To simplify a union type, any members that can be assigned to another member will be removed from the union. Shadowed types . TODO . Although simplifying (string | \"foo\" | \"bar\") into string is sound, we lose some more specific information about the original type that could be used by processors like auto completers. Therefore, for certain special cases, types that are trimmed during simplification may be accessible under the shadowedTypes property of the simplified type. ",
    "url": "/user/mcdoc/specification.html#type-simplification",
    "relUrl": "/user/mcdoc/specification.html#type-simplification"
  },"62": {
    "doc": "Specification",
    "title": "Type assignability",
    "content": "Types in mcdoc can be think of as sets. Type A is assignable to type B if and only if A is a subset of B. any is the universal set that contains all other types, and an empty union (()) is the empty set. unsafe (well, any is TypeScript&#8217;s unknown and unsafe is TypeScript&#8217;s any. A config rule will also be added to make any equivalent to unsafe that&#8217;s enabled by default so most users don&#8217;t have to deal with a tediously sound validation mechanism, as vanilla-mcdoc will probably use any instead of unsafe for marker&#8217;s data, which would make it illegal to assign it anywhere else that&#8217;s not an any or unsafe under a sound type system. I will update the docs and code later to add the unsafe type) is a monster that&#8217;s both any and (). TODO . TODO: Data validator hooks can contribute additional type assignability rules. e.g. | For JSON: byte = short = int = long = float = double . | For NBT: boolean = (byte @ 0..1) ⊂ byte . | . ",
    "url": "/user/mcdoc/specification.html#type-assignability",
    "relUrl": "/user/mcdoc/specification.html#type-assignability"
  },"63": {
    "doc": "Specification",
    "title": "Branding",
    "content": "\"Mcdoc\" is a common noun and should only have its first letter capitalized when it&#8217;s grammatically required to (e.g. at the beginning of the sentence). ",
    "url": "/user/mcdoc/specification.html#branding",
    "relUrl": "/user/mcdoc/specification.html#branding"
  },"64": {
    "doc": "Specification",
    "title": "Credits",
    "content": "The mcdoc format takes heavy inspiration from the nbtdoc format created by Yurihaia, licensed under the MIT License. Misode, MulverineX, NeunEinser, and vdvman1 also have provided valuable feedback for the mcdoc format. This documentation is written with AsciiDoc. ",
    "url": "/user/mcdoc/specification.html#credits",
    "relUrl": "/user/mcdoc/specification.html#credits"
  },"65": {
    "doc": "Specification",
    "title": "Specification",
    "content": "Table of Contents . | Project root | Syntax syntax | Comments | Doc comments | Integer | Float | Typed Number | Number range | String | Resource location | Identifier | Path | Type . | any type | boolean type | string type | Literal boolean type | Literal string type | Literal number type | Numeric type | Primitive array type | List type | Tuple type | Enum | Struct | Reference type | Dispatcher type | Union type | Indexing on a type | . | File Structure | Type alias statement . | Binding type parameters | . | Use statement | Injection | Dispatch statement | Attribute | Type instantiation . | Instantiate indexed type | Instantiate self-contained type | Instantiate container type | Instantiate reference type | Instantiate dispatcher type | Union type | Aftermath of instantiation | . | Type simplification . | Shadowed types | . | Type assignability | Branding | Credits | . This document defines the syntax and semantics of the mcdoc format. ",
    "url": "/user/mcdoc/specification.html",
    "relUrl": "/user/mcdoc/specification.html"
  },"66": {
    "doc": "undeclaredSymbol",
    "title": "Description",
    "content": "This rule specifies what actions should be done when there are undeclared symbols. ",
    "url": "/user/lint/undeclaredSymbol.html#description",
    "relUrl": "/user/lint/undeclaredSymbol.html#description"
  },"67": {
    "doc": "undeclaredSymbol",
    "title": "JSON Format",
    "content": "Either a simple Action object: . | (object) An action to take when encounterred undeclared symbols . | Either declare: declares the symbol at the specified scope. Allowed values: \"block\", \"file\", or \"public\". | Or report: reports a diagnostic with the specified severity. Allowed values: \"inherit\", \"hint\", \"information\", \"warning\", or \"error\". | . | . Or a more Complex structure with conditions: . | (object) . | if: (object) . | category: (string | string[]) . | pattern: (string | string[]) . | excludePattern: (string | string[]) . | namespace: (string | string[]) . | excludeNamespace: (string | string[]) . | . | then: (Action) . | override: (Complex | Complex[]) . | . | . Example 1. Example Config { \"lint\": { \"undeclaredSymbol\": [ { \"if\": [ { \"category\": [\"block\", \"entity_type\", \"item\"], \"namespace\": \"minecraft\" }, { \"category\": [\"advancement\", \"bossbar\", \"objective\", \"team\"] }, ], \"then\": { \"report\": \"warning\" }, }, { \"then\": { \"declare\": \"block\" }, }, ] } } . 👍 Good tag @s add foo . 👎 Bad setblock ~ ~ ~ minecraft:foo . Severity . All diagnostics provided by this linter will be of warning severity by default. You can wrap the config value in a tuple like this to change the severity to one of error, warning, information, or hint: . Config { \"lint\": { \"undeclaredSymbol\": [\"error\", &lt;value&gt;] } } . To Disable . If you do not wish to utilize this rule, simply set it to null: . Config { \"lint\": { \"undeclaredSymbol\": null } } . ",
    "url": "/user/lint/undeclaredSymbol.html#json-format",
    "relUrl": "/user/lint/undeclaredSymbol.html#json-format"
  },"68": {
    "doc": "undeclaredSymbol",
    "title": "undeclaredSymbol",
    "content": " ",
    "url": "/user/lint/undeclaredSymbol.html",
    "relUrl": "/user/lint/undeclaredSymbol.html"
  },"69": {
    "doc": "Update Guide",
    "title": "Update Guide",
    "content": "This document is intended for maintainers of the Spyglass project. Searchable comments // DOCS: Update here when format_version is changed. // DOCS: Update here when a new major version of Minecraft is released. ",
    "url": "/maintainer/update_guide.html",
    "relUrl": "/maintainer/update_guide.html"
  },"70": {
    "doc": "Web API",
    "title": "Introduction",
    "content": "The Spyglass Web API provides access to various information that is helpful for data pack/resource pack toolings. It uses misode/mcmeta and SpyglassMC/vanilla-mcdoc under the hood and provides a few advantages over using the GitHub API directly: . | Accessible within regions that have blocked raw.githubusercontent.com access. | Cache invalidation is handled through standard HTTP headers like ETag and If-None-Match; no more git commit sha hackery needed on client side. | Cleaner? . | . ",
    "url": "/developer/web-api.html#introduction",
    "relUrl": "/developer/web-api.html#introduction"
  },"71": {
    "doc": "Web API",
    "title": "General Usage",
    "content": "The Spyglass API root endpoint is https://api.spyglassmc.com/. Clients must identify themselves using the User-Agent HTTP header; requests without the User-Agent header will be rejected. Error Handling . All error responses (HTTP status code 4xx and 5xx) will include a JSON body with the following structure: . | message: (str) A human readable message describing the error details. | . Conditional Requests . All API endpoints include an ETag header in the response. Clients should cache the value of ETag along with the response body if possible, which can be achieved using the CacheStorage API on browsers. For future requests at the same endpoint, clients should include the value of ETag in the If-None-Match request header. A 304 Not Modified response will be returned if the resource has not changed since the last response. Ratelimiting . Ratelimiting is generous and should not be hit by normal usage. ",
    "url": "/developer/web-api.html#general-usage",
    "relUrl": "/developer/web-api.html#general-usage"
  },"72": {
    "doc": "Web API",
    "title": "Endpoints",
    "content": "GET /mcje/versions . GET /mcje/versions/:version/block_states . GET /mcje/versions/:version/commands . GET /mcje/versions/:version/registries . GET /mcje/versions/:version/vanilla-assets-tiny/tarball . GET /mcje/versions/:version/vanilla-data/tarball . GET /vanilla-mcdoc/symbols . GET /vanilla-mcdoc/tarball . POST /hooks/github . Not for third party use. This endpoint accepts GitHub Webhook deliveries to update the local Git repositories. ",
    "url": "/developer/web-api.html#endpoints",
    "relUrl": "/developer/web-api.html#endpoints"
  },"73": {
    "doc": "Web API",
    "title": "Web API",
    "content": "Table of Contents . | Introduction | General Usage . | Error Handling | Conditional Requests | Ratelimiting | . | Endpoints . | GET /mcje/versions | GET /mcje/versions/:version/block_states | GET /mcje/versions/:version/commands | GET /mcje/versions/:version/registries | GET /mcje/versions/:version/vanilla-assets-tiny/tarball | GET /mcje/versions/:version/vanilla-data/tarball | GET /vanilla-mcdoc/symbols | GET /vanilla-mcdoc/tarball | POST /hooks/github | . | . ",
    "url": "/developer/web-api.html",
    "relUrl": "/developer/web-api.html"
  }
}
